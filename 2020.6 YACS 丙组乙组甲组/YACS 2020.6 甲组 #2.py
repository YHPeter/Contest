# YACS 2020.6 甲组 #2

''''
题目背景
在图论问题中，支配是一个特定的术语，用于描述点与点之间的相邻关系。若 uu 和 vv 之间存在一条边，则称 uu 可以支配 vv。
若某些结点可以支配图中其他所有结点，则这些点构成了这张图的一个支配集。寻找支配集可以应用于很多场景，比如街道上的摄像机安装，手机网络的基站选址等等。
若图的结构比较复杂，则寻找最优的支配集是一件非常困难的事情，但在一些比较简单的结构上，例如在树上，是存在高效解法的。

题目描述
给定一棵拥有 nn 个结点的树，11 号点为这棵树的根，每个结点有一个权值，请找出这棵树的最优支配集。
所谓支配集，是一个由树上结点构成的子集，树上不属于这个子集的结点，都能找到至少一个邻居属于这个子集。
一个支配集的总权值，就是所有属于这个支配集的结点的权值之和。所谓最优支配集，就是具有最小总权值的支配集。

输入格式
第一行：单个整数表示n；
第二行：n-1个整数表示p2到pn,pi表示i号点父亲的编号，保证有1≤pi<i。
第三行：n个整数表示w1到wn,wi表示i号点的权值。

输出格式
单个整数，表示最优支配集的总权值大小

样例数据
输入:
5
1 1 2 2
90 50 30 30 30
输出:
80
说明:
取2号点和3号点作为支配集
'''
# sample answer from https://iai.sh.cn/contribution/172
e = [[0] for _ in range(200010)]
w = [[0] for _ in range(200010)]
dp = [[[0] for _ in range(200010)] for _ in range(3)]

def cal(u,f):
    inc = 99999999999 # 记录由某个子节点由 dp[v][1] 变成 dp[v][0] 的最小花费。 
    flag = False # 记录dp[u][1]是否全部由dp[v][1]得来 

    dp[u][0] = w[u] # 本身在支配集中，加上该点花费 

    for i in range(len(e[u])):
        v = e[u][i] # 子节点 
        
        if v == f: continue # 排除父节点 
        
        cal(v,u) # 优先计算子节点的dp值 
        
        dp[u][0] += min(dp[v][0],min(dp[v][1],dp[v][2])) # 计算dp[u][0]
        dp[u][2] += min(dp[v][0],dp[v][1]) # 计算dp[u][2]

        if dp[v][0] <= dp[v][1]:
            flag = True
            dp[u][1] += dp[v][0]
        else:
            inc = min(inc,(dp[v][0] - dp[v][1]))
            dp[u][1] += dp[v][1]
        # 计算临时的dp[u][1]
    if flag == 0: dp[u][1] += inc # 如果计算dp[u][1]时没有用到dp[v][0]，那么选一个最小花费的子节点转变成dp[v][0] 
    pass

n = int(input())
y_li = [0,0]+list(map(int,input().split(' ')))
for x in range(2,n+1):
    y = y_li[x]
    e[x] = y
    e[y] = x
w = [0]+list(map(int,input().split(' ')))
cal(1,0)
print(min(dp[1][0],dp[1][1])) # 1号节点本身也要被覆盖 
